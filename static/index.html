<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>AI Generation Progress</title>
    <style>
      html,
      body {
        font-family: monospace;
      }
      input {
        font-family: monospace;
        flex-grow: 1;
      }
      .tool {
        display: flex;
        flex-direction: row;
        align-items: center;
        margin-bottom: 10px;
        width: 100%;
        justify-content: space-between;
      }
      #shuffle {
        margin-left: 10px;
      }
      #seed {
        font-size: 14px;
        margin-left: 10px;
      }
      .prompt-container {
        max-width: 500px;
        display: flex;
        flex-direction: column;
      }
    </style>
  </head>
  <body>
    <div class="tool">
      <button id="haiku">haiku</button>
      <input type="text" value="space suit" id="prompt-input" />
      <div id="seed"></div>
      <button id="shuffle">ðŸŽ²</button>
    </div>

    <button class="prompt-mod">prompt mod</button>
    <label
      >Size:
      <select class="size-toggle">
        <option>small</option>
        <option>big</option>
        <option>biggest</option>
      </select>
    </label>

    <div id="progress" class="canvas-container">
      <!-- <canvas id="canvas"></canvas> -->
    </div>
    <div id="ranges"></div>
    <script type="module">
      function floyd(image) {
        var imageData = image.data;
        var imageDataLength = imageData.length;
        var w = image.width;
        var lumR = [],
          lumG = [],
          lumB = [];

        var newPixel, err;

        for (var i = 0; i < 256; i++) {
          lumR[i] = i * 0.299;
          lumG[i] = i * 0.587;
          lumB[i] = i * 0.11;
        }

        // Greyscale luminance (sets r pixels to luminance of rgb)
        for (var i = 0; i <= imageDataLength; i += 4) {
          imageData[i] = Math.floor(
            lumR[imageData[i]] + lumG[imageData[i + 1]] + lumB[imageData[i + 2]]
          );
        }

        for (
          var currentPixel = 0;
          currentPixel <= imageDataLength;
          currentPixel += 4
        ) {
          // threshold for determining current pixel's conversion to a black or white pixel
          newPixel = imageData[currentPixel] < 150 ? 0 : 255;
          err = Math.floor((imageData[currentPixel] - newPixel) / 23);
          imageData[currentPixel + 0 * 1 - 0] = newPixel;
          imageData[currentPixel + 4 * 1 - 0] += err * 7;
          imageData[currentPixel + 4 * w - 4] += err * 3;
          imageData[currentPixel + 4 * w - 0] += err * 5;
          imageData[currentPixel + 4 * w + 4] += err * 1;
          // Set g and b values equal to r (effectively greyscales the image fully)
          imageData[currentPixel + 1] = imageData[currentPixel + 2] =
            imageData[currentPixel];
        }

        return image;
      }
      let haikus;
      let seed;
      let prompt, prompt_embeds;
      const newSeed = () => {
        seed = Math.floor(Math.random() * 0xffffffff);
        localStorage.setItem("seed", String(seed));
        updateSeed();
      };

      const updateSeed = () => {
        document.querySelector("#seed").textContent = seed;
      };

      const initialSeed = localStorage.getItem("seed");
      if (initialSeed) {
        seed = parseInt(initialSeed, 10);
        updateSeed();
      } else {
        newSeed();
      }

      const canvasContainer = document.querySelector(".canvas-container");

      let width = 256;
      let height = 256;
      const STEPS = 8;
      const input = document.querySelector("#prompt-input");
      // const canvas = document.querySelector("#canvas");
      // canvas.style.maxHeight = "256px";
      // const context = canvas.getContext("2d");

      let promptIndex = 0;

      // const promptCanvas = document.querySelector("#prompt-canvas");
      // const promptContext = promptCanvas.getContext("2d");
      // promptCanvas.width = width;
      // promptCanvas.height = height;

      prompt = localStorage.getItem("prompt") || "space suit";
      input.value = prompt;

      const sizer = document.querySelector(".size-toggle");
      sizer.oninput = () => {
        if (sizer.value === "small") {
          width = height = 256;
          height = 512;
        } else if (sizer.value === "big") {
          width = height = 512;
        } else if (sizer.value === "biggest") {
          width = height = 768;
        }
        onPromptOrSeedChange();
      };

      // const promptIndexEl = document.querySelector(".prompt-index");
      document.querySelector(".prompt-mod").onclick = async (ev) => {
        ev.preventDefault();

        if (!prompt_embeds) {
          console.log("Fetching embedding..");
          prompt_embeds = await fetchPromptEmbedding(prompt);
        }
        const current = prompt_embeds;
        const newPrompt = await randomHaiku();
        console.log("new prompt", newPrompt);
        const embed = await fetchPromptEmbedding(newPrompt);
        for (let i = 0; i < current.length; i++) {
          for (let k = 0; k < current[i].length; k++) {
            const row = current[i][k];
            for (let x = 0; x < row.length; x++) {
              // prompt_embeds[i][k][x] *= 0.5;
              prompt_embeds[i][k][x] = lerp(
                prompt_embeds[i][k][x],
                embed[i][k][x],
                0.5
              );
            }
          }
        }

        onPromptOrSeedChange();
      };
      // promptIndexEl.oninput = () => {
      //   if (!prompt_embeds) return;
      //   const rows = prompt_embeds[0].length - 1;
      //   promptIndex = Math.max(
      //     0,
      //     Math.min(rows, parseInt(promptIndexEl.value, 10))
      //   );
      //   // drawPrompt1D();
      // };

      const randomHaiku = async () => {
        if (!haikus) {
          const txt = await (await fetch("haiku-23k.txt")).text();
          haikus = txt
            .split("\n")
            .map((line) => line.split("/").map((n) => n.trim()))
            .flat();
          console.log(haikus);
        }
        return haikus[Math.floor(Math.random() * haikus.length)];
      };

      document.querySelector("#haiku").onclick = async (ev) => {
        ev.preventDefault();
        input.value = await randomHaiku();
        textChange();
      };

      document.querySelector("#shuffle").onclick = async (ev) => {
        ev.preventDefault();
        newSeed();
        clearCanvasContainer();
        await onPromptOrSeedChange();
      };

      window.addEventListener("click", async (ev) => {
        if (ev.target.tagName.toLowerCase() === "canvas") {
          ev.preventDefault();
          const canvas = ev.target;
          const a = document.createElement("a");
          const blob = await new Promise((r) => canvas.toBlob(r, "image/png"));
          a.href = URL.createObjectURL(blob);
          a.download = Date.now() + ".png";
          a.click();
        }
      });

      let socket;
      let retry;
      const reconnect = () => {
        clearTimeout(retry);
        socket = new WebSocket("ws://localhost:8000/ws");
        socket.onopen = async () => {
          clearTimeout(retry);
          prompt = (input.value || "").trim();
          console.log("Connected");
          await promptTextChanged();
        };
        socket.onclose = async () => {
          clearTimeout(retry);
          retry = setTimeout(() => {
            console.log("Attempting reconnect");
            reconnect();
          }, 1000);
        };
      };
      reconnect();

      function ping() {
        if (socket.readyState === WebSocket.OPEN) {
          socket.send("ping");
        }
      }

      async function loadImage(uri) {
        return new Promise((resolve, reject) => {
          const img = new Image();
          img.src = uri;
          img.onload = () => {
            resolve(img);
          };
          img.onerror = () => reject(new Error(`Error loading image ${uri}`));
        });
      }

      function clearCanvasContainer() {
        while (canvasContainer.firstChild) {
          canvasContainer.firstChild.remove();
        }
      }

      socket.onmessage = async (event) => {
        if (event.data instanceof Blob) {
          const bitmap = await createImageBitmap(event.data);
          const canvas = document.createElement("canvas");
          canvas.width = bitmap.width;
          canvas.height = bitmap.height;
          const context = canvas.getContext("2d");
          context.drawImage(bitmap, 0, 0, canvas.width, canvas.height);
          clearCanvasContainer();
          canvasContainer.appendChild(canvas);
          // const imgData = context.getImageData(
          //   0,
          //   0,
          //   canvas.width,
          //   canvas.height
          // );
          // floyd(imgData);
          // context.putImageData(imgData, 0, 0);
          ping();
        } else {
          const data = JSON.parse(event.data);
          if (data.image) {
            const { image } = data;
            // const uri = "data:image/png;base64," + image;
            // const blob = await (await fetch(image)).blob();
            // console.log(image);
            const img = await loadImage(image);
            context.drawImage(img, 0, 0);
            ping();
          } else if (data.prompt_embeds) {
            // prompt_embeds = data.prompt_embeds;
            // drawPrompt1D();
          }
        }
      };

      input.oninput = textChange;

      async function textChange() {
        const value = (input.value || "").trim();
        if (value !== prompt) {
          prompt = value;
          await promptTextChanged();
          localStorage.setItem("prompt", prompt);
        }
      }

      async function fetchPromptEmbedding(p) {
        const queryString = new URLSearchParams({
          prompt: p,
        }).toString();
        const resp = await fetch(`/prompt?${queryString}`);
        return resp.json();
      }

      async function promptTextChanged() {
        prompt_embeds = null;
        onPromptOrSeedChange();
      }

      function onPromptOrSeedChange() {
        // drawPrompt2D();
        if (socket.readyState === WebSocket.OPEN) {
          const data = {
            width: width,
            height: height,
            seed: seed,
            steps: width >= 512 ? STEPS : STEPS,
            guidance_scale: 7.5,
          };
          if (prompt_embeds) data.prompt_embeds = prompt_embeds;
          else data.prompt = prompt;
          socket.send(JSON.stringify(data));
          ping();
        }
      }

      async function send() {
        if (socket.readyState !== WebSocket.OPEN) {
          return console.warn("Socket closed");
        }
        const prompt = input.value;

        // console.time("rpompt");

        // console.timeEnd("rpompt");
      }

      function drawPrompt1D() {
        if (!prompt_embeds) return;
        console.log("drawing", prompt_embeds);
        const data = prompt_embeds;
        const embedding = data[0];
        const rows = embedding.length;

        const row = embedding[promptIndex];
        const bins = row.length;
        promptCanvas.width = bins;
        promptCanvas.height = 256;
        // promptCanvas.style.height = "256px";
        // promptCanvas.style.width = "256px";
        promptCanvas.style.width = "100%";
        promptCanvas.style.height = "auto";
        const imageData = promptContext.createImageData(
          promptCanvas.width,
          promptCanvas.height
        );
        const imagePixels = imageData.data;
        const [min, max] = bounds(row);
        promptContext.beginPath();
        promptContext.strokeStyle = "black";
        for (let x = 0; x < bins; x++) {
          const idx = x;
          const L = inverseLerp(min, max, row[x]);
          promptContext.lineTo(x, L * promptCanvas.height);
        }
        promptContext.stroke();
        // promptContext.putImageData(imageData, 0, 0);
      }

      function drawPrompt2D() {
        const data = prompt_embeds;
        if (!data) return;
        const embedding = data[0];
        const rows = embedding.length;
        const dims = embedding[0].length;
        promptCanvas.width = dims;
        promptCanvas.height = rows;
        // promptCanvas.style.height = "256px";
        // promptCanvas.style.width = "256px";
        promptCanvas.style.width = "auto";
        promptCanvas.style.height = "auto";
        const imageData = promptContext.createImageData(
          promptCanvas.width,
          promptCanvas.height
        );
        const imagePixels = imageData.data;
        for (let y = 0; y < rows; y++) {
          const row = embedding[y];
          const [min, max] = bounds(row);
          for (let x = 0; x < dims; x++) {
            const idx = x + y * dims;
            const L = inverseLerp(min, max, row[x]) * 0xff;
            imagePixels[idx * 4 + 0] = L;
            imagePixels[idx * 4 + 1] = L;
            imagePixels[idx * 4 + 2] = L;
            imagePixels[idx * 4 + 3] = 0xff;
          }
        }
        promptContext.putImageData(imageData, 0, 0);
      }

      function inverseLerp(min, max, t) {
        if (Math.abs(min - max) < Number.EPSILON) return 0;
        else return (t - min) / (max - min);
      }

      function lerp(min, max, t) {
        return min * (1 - t) + max * t;
      }

      function bounds(dims) {
        let min = Infinity;
        let max = -Infinity;
        dims.forEach((d) => {
          min = Math.min(min, d);
          max = Math.max(max, d);
        });
        return [min, max];
      }

      function boundsMultiDim(items) {
        let min = Infinity;
        let max = -Infinity;
        items.forEach((list) => {
          list.forEach((dims) => {
            dims.forEach((d) => {
              min = Math.min(min, d);
              max = Math.max(max, d);
            });
          });
        });
        return [min, max];
      }
    </script>
  </body>
</html>
